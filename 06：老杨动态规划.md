# 快排，快排越有序越慢

**快排一次划分**

```cpp
//快排的一次划分
int partition(vector<int> & vec, int low, int high)
{
	//随机选取基准---------------------------------------
	int index = rand() % (high - low + 1) + low;
	swap(vec[low], vec[index]);
	//----------------------------------------------------

	int base = vec[low];

	while (low < high)
	{
		//从后往前找比基准小的
		while (low < high && vec[high] > base)		--high;
		if (low < high)		vec[low] = vec[high];

		//从前往后找比基准大的
		while (low < high && vec[low] <= base)	++low;
		if (low < high)		vec[high] = vec[low];
	}
	vec[low] = base;
	return low;
}
```

**快排递归**

```cpp
//递归
void quickSort(vector<int> & vec, int low, int high)
{
	int mid = partition(vec, low, high);
	if (mid - low > 1)
	{
		quickSort(vec, low, mid - 1);
	}
	if (high - mid > 1)
	{
		quickSort(vec, mid + 1, high);
	}
}
```

**快排非递归**

```cpp
//非递归
void quickSort2(vector<int> & vec, int low, int high)
{
	//用栈来存储左右下标
	stack<int> sta;
	sta.push(low);
	sta.push(high);

	while (!sta.empty())
	{
		int h = sta.top();	sta.pop();
		int l = sta.top();	sta.pop();

		int m = partition(vec, l, h);

		if (m - l > 1)
		{
			sta.push(l);
			sta.push(m - 1);
		}
		if (h - m > 1)
		{
			sta.push(m + 1);
			sta.push(h);
		}
	}
}
```

**单方向推进一次快排**

```cpp
int OWParition(vector<int>& br, int left, int right)
{
	int i = left, j = left + 1;
	int tmp = br[i];
	while (j <= right)
	{
		if (br[j] <= tmp)
		{
			++i;
			std::swap(br[i], br[j]);
		}
		++j;
	}
	std::swap(br[left], br[i]);
	return i;
}

```

**单链表快排（单方向推进**）

```cpp
ListNode* LinkParition(ListNode* left, ListNode* right)
{
	ListNode* ip = left;
	ListNode* jp = left->next;
	int tmp = left->data;
	while (jp != right)
	{
		if (jp->data <= tmp)
		{
			ip = ip->next;
			std::swap(ip->data, jp->data);
		}
		jp = jp->next;
	}
	std::swap(left->data, ip->data);
	return ip;
}
void QuickPass(ListNode* left, ListNode* right)
{
	if (left != right)
	{
		ListNode* p = LinkParition(left, right);
		QuickPass(left, p);
		QuickPass(p->next, right);
	}
}
```

**找第k小的数字**

```cpp
int Select_K(vector<int>& br, int left, int right, int k)
{
	if (left == right && k == 1) return br[left];
	int index = Parition(br, left, right);
	int pos = (index - left + 1);
	if (k <= pos) return Select_K(br, left, index, k);
	else return Select_K(br, index + 1, right, k - pos);
} 
int main()
{
	vector<int> ar = { 56,34,100,23,78,90,12,45,67,89 };
	for (int k = 1; k <= ar.size(); ++k)
	{
		cout << k << " => " << Select_K(ar, 0, ar.size() - 1, k) << endl;
	}
	return 0;
}
```

